<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>RDMA Slow vs Fast Path Amortization</title>
  <link rel="stylesheet" href="shared.css"/>
  <style>
    :root{
      --grid-cols:1fr 360px;
      --canvas-h:520px;
      --canvas-h-sm:460px;
    }
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:6px;font-size:12px;color:var(--muted);}
    .swatch{display:inline-block;width:10px;height:10px;border-radius:3px;margin-right:6px;}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Slow Path vs Fast Path (Amortization)</h1>
    <p class="sub">
      RDMA has a slow setup path (connection + memory registration) and a fast per-message path.
      This sim shows how many messages it takes to amortize setup.
    </p>

    <div class="grid">
      <div class="card">
        <div class="canvasWrap">
          <canvas id="c"></canvas>
        </div>
      </div>

      <div class="card controls">
        <div class="ctl">
          <div class="note">
            Toggle reuse to see how setup work amortizes. With reuse on, setup is paid once.
            With reuse off, setup becomes per-message and the crossover point moves out.
          </div>
        </div>
        <div class="ctl">
          <label><span>Message Count</span><strong><span id="countVal">200</span></strong></label>
          <input id="msgCount" type="range" min="10" max="2000" step="10" value="200"/>
        </div>

        <div class="ctl">
          <label><span>Reuse Connection</span><strong><span id="connVal">Yes</span></strong></label>
          <div class="tog">
            <div class="btn primary" id="connYes">Yes</div>
            <div class="btn" id="connNo">No</div>
          </div>
        </div>

        <div class="ctl">
          <label><span>Reuse MR</span><strong><span id="mrVal">Yes</span></strong></label>
          <div class="tog">
            <div class="btn primary" id="mrYes">Yes</div>
            <div class="btn" id="mrNo">No</div>
          </div>
        </div>

        <div class="ctl">
          <label><span>Setup Cost (units)</span><strong><span id="setupVal">1200</span></strong></label>
          <input id="setupCost" type="range" min="100" max="5000" step="50" value="1200"/>
        </div>

        <div class="ctl">
          <label><span>Per-Message Cost (units)</span><strong><span id="perVal">6</span></strong></label>
          <input id="perCost" type="range" min="1" max="30" step="1" value="6"/>
        </div>

        <div class="ctl">
          <div class="kv">
            <span>Total work</span><strong><span id="total">0</span></strong>
            <span>Amortized / msg</span><strong><span id="amort">0</span></strong>
            <span>Crossover N (â‰ˆ10% of fast path)</span><strong><span id="cross">-</span></strong>
          </div>
          <div class="legend">
            <span><span class="swatch" style="background:#ffb020"></span>Setup (one-time)</span>
            <span><span class="swatch" style="background:#4da3ff"></span>Setup (per-msg)</span>
            <span><span class="swatch" style="background:#6ee7b7"></span>Fast path</span>
          </div>
        </div>

        <div class="ctl">
          <label><span>Step</span><strong><span id="stepCount">1 / 4</span></strong></label>
          <div class="tog">
            <div class="btn primary" id="btnStep">Step</div>
            <div class="btn" id="btnBack">Back</div>
            <div class="btn" id="btnReset">Reset</div>
            <div class="btn" id="btnAuto">Autoplay</div>
          </div>
        </div>
      </div>
    </div>
  </div>

<script src="shared.js"></script>
<script>
/**
 * State machine: 4 steps; model vars: stepIndex, reuseConn, reuseMr, msgCount, setupCost, perCost, autoplay; render updates: bar stack, counters, text.
 */
(() => {
  const { ctx, canvas } = SimUI.setupCanvas('c');

  const el = {
    msgCount: document.getElementById('msgCount'),
    setupCost: document.getElementById('setupCost'),
    perCost: document.getElementById('perCost'),
    countVal: document.getElementById('countVal'),
    setupVal: document.getElementById('setupVal'),
    perVal: document.getElementById('perVal'),
    connYes: document.getElementById('connYes'),
    connNo: document.getElementById('connNo'),
    mrYes: document.getElementById('mrYes'),
    mrNo: document.getElementById('mrNo'),
    connVal: document.getElementById('connVal'),
    mrVal: document.getElementById('mrVal'),
    total: document.getElementById('total'),
    amort: document.getElementById('amort'),
    cross: document.getElementById('cross'),
    stepCount: document.getElementById('stepCount'),
    btnStep: document.getElementById('btnStep'),
    btnBack: document.getElementById('btnBack'),
    btnReset: document.getElementById('btnReset'),
    btnAuto: document.getElementById('btnAuto'),
  };

  const presets = [
    {msgCount: 200, reuseConn: true, reuseMr: true, setupCost: 1200, perCost: 6},
    {msgCount: 200, reuseConn: false, reuseMr: true, setupCost: 1200, perCost: 6},
    {msgCount: 400, reuseConn: false, reuseMr: false, setupCost: 1200, perCost: 6},
    {msgCount: 800, reuseConn: true, reuseMr: true, setupCost: 2000, perCost: 4},
  ];

  const model = {
    stepIndex: 0,
    msgCount: presets[0].msgCount,
    setupCost: presets[0].setupCost,
    perCost: presets[0].perCost,
    reuseConn: presets[0].reuseConn,
    reuseMr: presets[0].reuseMr,
    autoplay: false,
  };

  let timer = null;
  const renderHud = SimUI.createDebugHud(() => ({
    stepIndex: model.stepIndex,
    totalSteps: presets.length,
    msgCount: model.msgCount,
    setupCost: model.setupCost,
    perCost: model.perCost,
    reuseConn: model.reuseConn,
    reuseMr: model.reuseMr,
    autoplay: model.autoplay,
  }));

  function drawChart(setupOnce, setupPerMsgTotal, fastTotal, total) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const w = canvas.width;
    const h = canvas.height;
    const pad = 40;
    const chartW = w - pad * 2;
    const chartH = h - pad * 2;

    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.fillRect(pad, pad, chartW, chartH);

    const scale = total > 0 ? 1 / total : 0;
    const x = pad + chartW * 0.15;
    const barW = chartW * 0.5;
    let curY = pad + chartH;
    const parts = [
      { v: setupOnce, color: '#ffb020' },
      { v: setupPerMsgTotal, color: '#4da3ff' },
      { v: fastTotal, color: '#6ee7b7' },
    ];

    for (const part of parts) {
      const ph = chartH * (part.v * scale);
      curY -= ph;
      ctx.fillStyle = part.color;
      ctx.fillRect(x, curY, barW, ph);
    }

    ctx.strokeStyle = 'rgba(255,255,255,0.25)';
    ctx.strokeRect(x, pad, barW, chartH);
    ctx.fillStyle = '#e8eef7';
    ctx.font = '12px system-ui, sans-serif';
    ctx.fillText('Total work (setup + fast path)', x, pad - 12);
  }

  function applyPreset(idx) {
    const p = presets[idx];
    model.msgCount = p.msgCount;
    model.reuseConn = p.reuseConn;
    model.reuseMr = p.reuseMr;
    model.setupCost = p.setupCost;
    model.perCost = p.perCost;
  }

  function render() {
    const connSetup = model.setupCost * 0.5;
    const mrSetup = model.setupCost * 0.5;
    const setupOnce = (model.reuseConn ? connSetup : 0) + (model.reuseMr ? mrSetup : 0);
    const setupPerMsg = (model.reuseConn ? 0 : connSetup) + (model.reuseMr ? 0 : mrSetup);
    const setupPerMsgTotal = setupPerMsg * model.msgCount;
    const fastTotal = model.perCost * model.msgCount;
    const total = setupOnce + setupPerMsgTotal + fastTotal;
    const amort = total / model.msgCount;

    let crossover = '-';
    if (model.perCost > 0 && setupOnce > 0) {
      crossover = String(Math.ceil(setupOnce / (0.1 * model.perCost)));
    } else if (setupOnce === 0) {
      crossover = '1';
    }

    el.msgCount.value = String(model.msgCount);
    el.setupCost.value = String(model.setupCost);
    el.perCost.value = String(model.perCost);

    el.countVal.textContent = String(model.msgCount);
    el.setupVal.textContent = String(model.setupCost);
    el.perVal.textContent = String(model.perCost);

    el.connVal.textContent = model.reuseConn ? 'Yes' : 'No';
    el.mrVal.textContent = model.reuseMr ? 'Yes' : 'No';
    el.connYes.classList.toggle('primary', model.reuseConn);
    el.connNo.classList.toggle('primary', !model.reuseConn);
    el.mrYes.classList.toggle('primary', model.reuseMr);
    el.mrNo.classList.toggle('primary', !model.reuseMr);

    el.total.textContent = total.toFixed(0);
    el.amort.textContent = amort.toFixed(1);
    el.cross.textContent = crossover;
    el.stepCount.textContent = `${model.stepIndex + 1} / ${presets.length}`;
    el.btnAuto.textContent = model.autoplay ? 'Stop' : 'Autoplay';

    drawChart(setupOnce, setupPerMsgTotal, fastTotal, total);
    renderHud();
  }

  function stopAutoplay() {
    if (timer) clearInterval(timer);
    timer = null;
    model.autoplay = false;
  }

  function stepForward() {
    if (model.stepIndex < presets.length - 1) {
      model.stepIndex += 1;
      applyPreset(model.stepIndex);
    } else {
      stopAutoplay();
    }
    render();
  }

  function stepBack() {
    model.stepIndex = Math.max(0, model.stepIndex - 1);
    applyPreset(model.stepIndex);
    render();
  }

  function reset() {
    model.stepIndex = 0;
    applyPreset(0);
    stopAutoplay();
    render();
  }

  function toggleAuto() {
    if (model.autoplay) {
      stopAutoplay();
      render();
      return;
    }
    model.autoplay = true;
    render();
    timer = setInterval(() => {
      if (model.stepIndex >= presets.length - 1) {
        stopAutoplay();
        render();
      } else {
        model.stepIndex += 1;
        applyPreset(model.stepIndex);
        render();
      }
    }, 1200);
  }

  el.msgCount.addEventListener('input', () => { model.msgCount = Number(el.msgCount.value); render(); });
  el.setupCost.addEventListener('input', () => { model.setupCost = Number(el.setupCost.value); render(); });
  el.perCost.addEventListener('input', () => { model.perCost = Number(el.perCost.value); render(); });

  el.connYes.onclick = () => { model.reuseConn = true; render(); };
  el.connNo.onclick = () => { model.reuseConn = false; render(); };
  el.mrYes.onclick = () => { model.reuseMr = true; render(); };
  el.mrNo.onclick = () => { model.reuseMr = false; render(); };

  el.btnStep.onclick = stepForward;
  el.btnBack.onclick = stepBack;
  el.btnReset.onclick = reset;
  el.btnAuto.onclick = toggleAuto;

  render();
})();
</script>
</body>
</html>
