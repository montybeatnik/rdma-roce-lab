<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Topology Overlay Simulation</title>
  <link rel="stylesheet" href="shared.css"/>
  <style>
    :root{
      --wrap-max:1200px;
      --grid-cols:1fr 360px;
      --canvas-h:580px;
      --canvas-h-sm:520px;
    }
    @media (max-width: 1020px){
      .grid{grid-template-columns:1fr;}
      canvas{height:520px;}
    }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Topology Overlay: Where the Pressure Goes</h1>
  <p class="sub">
    Rail mode rule: <strong>same-rail stays on that rail</strong>. If traffic crosses rails, it <strong>traverses the spine layer</strong>.
    Rail A traffic is tinted <strong>cyan</strong>, Rail B <strong>blue</strong>, spine traversal <strong>purple</strong>.
  </p>

  <div class="grid">
    <div class="card">
      <div class="canvasWrap"><canvas id="c"></canvas></div>
    </div>

    <div class="card controls">
      <div class="ctl">
        <label><span>Topology</span><span class="pill" id="topoLabel">Leaf–Spine</span></label>
        <div class="tog">
          <div class="btn primary" id="btnLeafSpine">Leaf–Spine</div>
          <div class="btn" id="btnRails">Rail-Oriented</div>
        </div>
        <div class="note">
          Rail mode enforces: same-rail → rail path, cross-rail → spine path.
        </div>
      </div>

      <div class="ctl">
        <label><span>Traffic Pattern</span><span class="pill" id="patternLabel">Fan-in Burst</span></label>
        <div class="tog">
          <div class="btn primary" id="patFanIn">Fan-in Burst</div>
          <div class="btn" id="patAllToAll">All-to-All</div>
          <div class="btn" id="patIncAst">Inc-AST (Staggered)</div>
        </div>
      </div>

      <div class="ctl">
        <label><span>Total GPUs</span><strong><span id="nVal">12</span></strong></label>
        <input id="n" type="range" min="8" max="24" step="1" value="12"/>
        <div class="note">
          GPUs are packed into servers (4 per server). GPU1→Leaf1 … GPU4→Leaf4.<br/>
          Rail assignment: GPU1–2 → Rail A, GPU3–4 → Rail B.
        </div>
      </div>

      <div class="ctl">
        <label><span>Intensity</span><strong><span id="intVal">1.10</span></strong></label>
        <input id="intensity" type="range" min="0.40" max="1.80" step="0.05" value="1.10"/>
      </div>

      <div class="ctl">
        <label><span>Hotspot Sensitivity</span><strong><span id="hotVal">0.65</span></strong></label>
        <input id="hotspot" type="range" min="0.20" max="0.95" step="0.05" value="0.65"/>
      </div>

      <div class="ctl">
        <label><span>Presets</span><span class="pill">One-click scenes</span></label>
        <div class="tog">
          <div class="btn" id="pCalm">Calm</div>
          <div class="btn primary" id="pHot">Hotspot</div>
          <div class="btn" id="pCompare">Compare</div>
          <div class="btn" id="demo">Demo Mode</div>
          <div class="btn danger" id="reset">Reset</div>
        </div>
        <div class="kv">
          <span>Instant “pressure”</span><strong><span id="pressureNow">0%</span></strong>
          <span>Hottest link</span><strong><span id="hottestNow">0%</span></strong>
        </div>
      </div>

      <div class="ctl">
        <div class="tog">
          <div class="btn primary" id="toggleRun">Pause</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="shared.js"></script>
<script>
(() => {
  const { canvas, ctx } = SimUI.setupCanvas('c');

  // UI
  const el = {
    topoLabel: document.getElementById('topoLabel'),
    btnLeafSpine: document.getElementById('btnLeafSpine'),
    btnRails: document.getElementById('btnRails'),

    patternLabel: document.getElementById('patternLabel'),
    patFanIn: document.getElementById('patFanIn'),
    patAllToAll: document.getElementById('patAllToAll'),
    patIncAst: document.getElementById('patIncAst'),

    n: document.getElementById('n'),
    intensity: document.getElementById('intensity'),
    hotspot: document.getElementById('hotspot'),
    nVal: document.getElementById('nVal'),
    intVal: document.getElementById('intVal'),
    hotVal: document.getElementById('hotVal'),

    pCalm: document.getElementById('pCalm'),
    pHot: document.getElementById('pHot'),
    pCompare: document.getElementById('pCompare'),
    demo: document.getElementById('demo'),
    reset: document.getElementById('reset'),
    toggleRun: document.getElementById('toggleRun'),

    pressureNow: document.getElementById('pressureNow'),
    hottestNow: document.getElementById('hottestNow'),
  };

  const bindRange = SimUI.bindRange;
  bindRange(el.n, el.nVal, v=>String(v));
  bindRange(el.intensity, el.intVal, v=>Number(v).toFixed(2));
  bindRange(el.hotspot, el.hotVal, v=>Number(v).toFixed(2));

  let running = true;
  el.toggleRun.onclick = ()=>{ running = !running; el.toggleRun.textContent = running ? 'Pause' : 'Play'; };

  // State
  let topo = 'leafspine';    // leafspine | rails
  let pattern = 'fanin';     // fanin | alltoall | incast
  let t = 0;

  // Graph primitives
  let nodes = [];        // switches + gpu nodes (servers tracked separately)
  let servers = [];      // {id,x,y,w,h,label,gpuIds[]}
  let links = [];        // {a,b,heat,cap,kind}
  let particles = [];    // {a,b,p,x,y,speed,kind}

  // Model
  const LEAF_COUNT = 4;
  const GPUS_PER_SERVER = 4;

  // Demo timers
  let demoTimers = [];
  let demoRunning = false;

  function clearDemo(){
    for(const id of demoTimers) clearTimeout(id);
    demoTimers = [];
    demoRunning = false;
    el.demo.textContent = 'Demo Mode';
  }

  // Helpers
  const rnd = ()=> Math.random();
  const clamp = (x,a,b)=> Math.max(a, Math.min(b,x));
  const lerp = (a,b,p)=> a + (b-a)*p;

  function roundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }
  function text(s,x,y,size=12,color='rgba(167,179,197,0.9)',align='left'){
    ctx.save();
    ctx.font = `${size}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
    ctx.fillStyle = color;
    ctx.textAlign = align;
    ctx.fillText(s,x,y);
    ctx.restore();
  }

  // Color scheme for "kinds" (used for rail tinting)
  function baseColorForKind(kind){
    // Keep hotspots meaningful: once heat is high, we override to orange/red.
    if (kind === 'railA') return 'rgba(56,189,248,0.45)';   // cyan
    if (kind === 'railB') return 'rgba(59,130,246,0.45)';   // blue
    if (kind === 'spineX') return 'rgba(168,85,247,0.45)';  // purple
    if (kind === 'uplink') return 'rgba(255,255,255,0.10)'; // neutral
    return 'rgba(255,255,255,0.08)';
  }

  function setTopo(next){
    topo = next;
    el.topoLabel.textContent = (topo === 'leafspine') ? 'Leaf–Spine' : 'Rail-Oriented';
    el.btnLeafSpine.classList.toggle('primary', topo === 'leafspine');
    el.btnRails.classList.toggle('primary', topo === 'rails');
    rebuild();
  }
  function setPattern(next){
    pattern = next;
    el.patternLabel.textContent = (pattern === 'fanin') ? 'Fan-in Burst' :
                                  (pattern === 'alltoall') ? 'All-to-All' : 'Inc-AST (Staggered)';
    el.patFanIn.classList.toggle('primary', pattern === 'fanin');
    el.patAllToAll.classList.toggle('primary', pattern === 'alltoall');
    el.patIncAst.classList.toggle('primary', pattern === 'incast');
    resetFlows();
  }

  el.btnLeafSpine.onclick = ()=> setTopo('leafspine');
  el.btnRails.onclick = ()=> setTopo('rails');
  el.patFanIn.onclick = ()=> setPattern('fanin');
  el.patAllToAll.onclick = ()=> setPattern('alltoall');
  el.patIncAst.onclick = ()=> setPattern('incast');

  function resetFlows(){
    particles.length = 0;
    for(const L of links) L.heat = 0;
    t = 0;
  }
  el.reset.onclick = ()=>{ clearDemo(); resetFlows(); };

  function addLink(a,b,cap,kind='uplink'){
    links.push({ a:a.id, b:b.id, heat:0, cap, kind });
  }

  function nodeById(id){ return nodes.find(n=>n.id===id); }
  function linkBetween(aId,bId){
    return links.find(L => (L.a===aId && L.b===bId) || (L.a===bId && L.b===aId));
  }

  function gpuNodes(){ return nodes.filter(n=>n.type==='gpu'); }

  // Build topology graph
  function rebuild(){
    particles.length = 0;
    nodes.length = 0;
    servers.length = 0;
    links.length = 0;
    t = 0;

    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    const margin = 34;
    const topY = 86;
    const bottomY = h - 86;

    const N = Number(el.n.value);
    const nServers = Math.max(1, Math.ceil(N / GPUS_PER_SERVER));

    // Leaves
    const leafY = h * 0.56;
    const leafStartX = margin + 90;
    const leafEndX = w - margin - 90;

    for(let i=0;i<LEAF_COUNT;i++){
      const x = lerp(leafStartX, leafEndX, (LEAF_COUNT===1?0.5:(i/(LEAF_COUNT-1))));
      nodes.push({ id:`L${i}`, x, y:leafY, type:'leaf', label:`Leaf ${i+1}` });
    }

    // Upper layer
    const upperY = topY + 40;

    if (topo === 'leafspine'){
      const nSpines = 3;
      const spStartX = margin + 160;
      const spEndX = w - margin - 160;
      for(let i=0;i<nSpines;i++){
        const x = lerp(spStartX, spEndX, (nSpines===1?0.5:(i/(nSpines-1))));
        nodes.push({ id:`S${i}`, x, y:upperY, type:'spine', label:`Spine ${i+1}` });
      }
    } else {
      // ✅ No single "spine device" — instead, a spine *layer* used for inter-rail
      nodes.push({ id:`RA`, x:w*0.30, y:upperY, type:'rail', label:`Rail A` });
      nodes.push({ id:`RB`, x:w*0.70, y:upperY, type:'rail', label:`Rail B` });

      // spine layer (inter-rail)
      const spineCount = 2;
      for(let i=0;i<spineCount;i++){
        const x = lerp(w*0.42, w*0.58, spineCount===1?0.5:(i/(spineCount-1)));
        nodes.push({ id:`X${i}`, x, y:upperY-10, type:'spineX', label:`Spine ${i+1}` });
      }
    }

    const leaves = nodes.filter(n=>n.type==='leaf');
    const spines = nodes.filter(n=>n.type==='spine');
    const rails  = nodes.filter(n=>n.type==='rail');
    const xspines = nodes.filter(n=>n.type==='spineX');

    // Servers row
    const usableW = (w - 2*margin);
    const maxBoxW = 156;
    const boxW = Math.min(maxBoxW, Math.max(126, (usableW / nServers) - 12));
    const boxH = 86;

    const totalRowW = nServers * boxW + (nServers-1) * 14;
    let startX = (w - totalRowW) / 2;
    startX = Math.max(margin, startX);

    const padX = 18;
    const portYInset = 18;

    let gpuCreated = 0;

    for(let s=0;s<nServers;s++){
      const x = startX + s*(boxW + 14);
      const yCenter = bottomY - (boxH/2);

      const sid = `SV${s}`;
      const label = `Server ${s+1}`;
      const gpuIds = [];

      const localW = boxW - padX*2;
      const topBox = (yCenter - boxH/2);
      const portY = topBox + portYInset;

      for(let g=0; g<GPUS_PER_SERVER; g++){
        if (gpuCreated >= N) break;

        const gid = `G${s}_${g}`;
        gpuIds.push(gid);

        const gx = x + padX + (localW * (g/(GPUS_PER_SERVER-1)));
        const gy = portY;

        // Rail assignment: GPU1-2 -> A, GPU3-4 -> B
        const railIndex = (g < 2) ? 0 : 1;

        nodes.push({
          id: gid,
          x: gx,
          y: gy,
          type: 'gpu',
          label: `GPU${g+1}`,
          server: sid,
          gpuIndex: g,
          railIndex
        });

        // GPU(g) -> Leaf(g) (neutral)
        addLink({id:gid}, {id:`L${g}`}, 1.0, 'uplink');

        gpuCreated++;
      }

      servers.push({ id:sid, x, y:yCenter, w:boxW, h:boxH, label, gpuIds });
    }

    // Uplinks
    if (topo === 'leafspine'){
      for(const leaf of leaves){
        for(const spine of spines){
          addLink(leaf, spine, 1.0, 'uplink');
        }
      }
    } else {
      // leaf -> rails (colored by rail)
      for(const leaf of leaves){
        addLink(leaf, rails[0], 1.0, 'railA');
        addLink(leaf, rails[1], 1.0, 'railB');
      }
      // leaf -> spine layer (purple)
      for(const leaf of leaves){
        for(const sx of xspines){
          addLink(leaf, sx, 1.0, 'spineX');
        }
      }
    }
  }

  // Flow picking
  function pickFlows(){
    const gpus = gpuNodes();
    if (gpus.length < 2) return [];

    let pairs = [];
    if (pattern === 'fanin'){
      const target = gpus[Math.floor(gpus.length*0.65)];
      for(const g of gpus){
        if (g.id === target.id) continue;
        pairs.push([g.id, target.id]);
      }
    } else if (pattern === 'alltoall'){
      const k = Math.max(10, Math.floor(gpus.length*1.3));
      for(let i=0;i<k;i++){
        let a = gpus[Math.floor(rnd()*gpus.length)].id;
        let b = gpus[Math.floor(rnd()*gpus.length)].id;
        if (a===b) { i--; continue; }
        pairs.push([a,b]);
      }
    } else { // incast staggered
      const target = gpus[Math.floor(gpus.length*0.35)];
      const waveSize = Math.max(3, Math.floor(gpus.length*0.30));
      const wave = Math.floor((t % 3.0) / 0.75);
      for(let i=0;i<waveSize;i++){
        const idx = (wave*waveSize + i) % gpus.length;
        const src = gpus[idx];
        if (src.id === target.id) continue;
        pairs.push([src.id, target.id]);
      }
    }
    return pairs;
  }

  function gpuToLeaf(gid){
    const G = nodeById(gid);
    if (!G || G.type !== 'gpu') return null;
    return `L${G.gpuIndex}`;
  }

  function gpuToRail(gid){
    const G = nodeById(gid);
    if (!G || G.type !== 'gpu') return null;
    return (G.railIndex === 0) ? 'RA' : 'RB';
  }

  // Routing:
  // Rails mode:
  //  - same rail => GPU -> Leaf -> Rail -> Leaf -> GPU
  //  - cross rail => GPU -> Leaf -> SpineX -> Leaf -> GPU (choose a spine)
  function route(aG, bG){
    const aL = gpuToLeaf(aG);
    const bL = gpuToLeaf(bG);
    if (!aL || !bL) return [aG,bG];

    if (aL === bL) return [aG, aL, bG];

    if (topo === 'leafspine'){
      const spines = nodes.filter(n=>n.type==='spine').map(n=>n.id);
      const pick = spines[(hash(aG + '->' + bG) % spines.length + spines.length) % spines.length];
      return [aG, aL, pick, bL, bG];
    }

    // rails topology
    const aR = gpuToRail(aG);
    const bR = gpuToRail(bG);
    if (aR && bR && aR === bR){
      return [aG, aL, aR, bL, bG];
    }

    const xsp = nodes.filter(n=>n.type==='spineX').map(n=>n.id);
    const pickX = xsp[(hash('X:' + aG + '->' + bG) % xsp.length + xsp.length) % xsp.length];
    return [aG, aL, pickX, bL, bG];
  }

  function hash(s){
    let h=0;
    for(let i=0;i<s.length;i++) h = (h*31 + s.charCodeAt(i)) | 0;
    return h;
  }

  // Particles
  function spawnPath(path, intensity){
    for(let i=0;i<path.length-1;i++){
      const A = nodeById(path[i]);
      const B = nodeById(path[i+1]);
      if (!A || !B) continue;

      const speed = 0.60 + intensity*0.55 + rnd()*0.18;
      const L = linkBetween(A.id,B.id);
      const kind = L ? L.kind : 'uplink';

      particles.push({ a:A.id, b:B.id, p:0, x:A.x, y:A.y, speed, kind });

      if (L) L.heat = clamp(L.heat + 0.018 * intensity * Number(el.hotspot.value), 0, 1);
    }
  }

  function step(dt){
    t += dt;
    const intensity = Number(el.intensity.value);

    const pairs = pickFlows();

    // Burstiness
    let burst = 1.0;
    if (pattern === 'fanin'){
      const beat = (t % 1.6) / 1.6;
      const d = Math.abs(beat - 0.22);
      burst = Math.exp(-(d*d)/(2*0.07*0.07));
      burst = 0.15 + burst * 1.25;
    } else if (pattern === 'incast'){
      burst = 0.55 + 0.55 * Math.sin(t*3.1)*0.5 + 0.25;
      burst = clamp(burst, 0.25, 1.25);
    }

    const budget = Math.min(30, Math.floor(pairs.length * intensity * burst));
    for(let i=0;i<budget;i++){
      const [a,b] = pairs[i % pairs.length];
      spawnPath(route(a,b), intensity * burst);
    }

    // cool links
    for(const L of links){
      L.heat = clamp(L.heat * (1 - dt*0.55), 0, 1);
    }

    // move particles
    for(let i=particles.length-1;i>=0;i--){
      const P = particles[i];
      const A = nodeById(P.a), B = nodeById(P.b);
      if (!A || !B){ particles.splice(i,1); continue; }
      P.p += dt * P.speed;
      if (P.p >= 1){ particles.splice(i,1); continue; }
      P.x = lerp(A.x,B.x,P.p);
      P.y = lerp(A.y,B.y,P.p);
    }

    // stats
    const hottest = links.reduce((m,L)=> Math.max(m, L.heat), 0);
    const pressure = clamp((particles.length / 240) + hottest*0.6, 0, 1);
    el.pressureNow.textContent = `${Math.round(pressure*100)}%`;
    el.hottestNow.textContent = `${Math.round(hottest*100)}%`;
  }

  function patternLabel(){
    return (pattern === 'fanin') ? 'Fan-in Burst' : (pattern === 'alltoall') ? 'All-to-All' : 'Inc-AST (Staggered)';
  }

  // Render
  function render(){
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;
    ctx.clearRect(0,0,w,h);

    // grid
    ctx.save();
    ctx.strokeStyle='rgba(255,255,255,0.04)';
    ctx.lineWidth=1;
    for(let y=40;y<h;y+=40){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
    }
    ctx.restore();

    text('Rail mode: cyan/blue rails. Cross-rail: purple spine traversal.', 28, 34, 12, 'rgba(167,179,197,0.92)');
    text(`${topo === 'leafspine' ? 'Leaf–Spine' : 'Rail-Oriented'} • ${patternLabel()}`, w-28, 34, 12, 'rgba(232,238,247,0.78)', 'right');

    // links (heat + rail tint)
    for(const L of links){
      const A = nodeById(L.a), B = nodeById(L.b);
      if (!A || !B) continue;

      const heat = L.heat;

      // Heat overrides (keep semantics)
      let col;
      if (heat > 0.70) col = `rgba(255,92,92,0.65)`;
      else if (heat > 0.40) col = `rgba(255,176,32,0.55)`;
      else col = baseColorForKind(L.kind);

      ctx.save();
      ctx.strokeStyle = col;
      ctx.lineWidth = 2 + heat*6;
      ctx.beginPath();
      ctx.moveTo(A.x,A.y);
      ctx.lineTo(B.x,B.y);
      ctx.stroke();
      ctx.restore();
    }

    // switches
    for(const N of nodes){
      if (N.type === 'gpu') continue;
      drawSwitchNode(N);
    }

    // servers
    for(const S of servers){
      drawServer(S);
    }

    // particles (colored by link kind, but still gets "hotter" feel when overall heat rises)
    const heatMax = links.reduce((m,L)=> Math.max(m, L.heat), 0);
    for(const P of particles){
      ctx.save();

      let col;
      if (heatMax > 0.70) col = 'rgba(255,92,92,0.75)';
      else if (heatMax > 0.40) col = 'rgba(255,176,32,0.75)';
      else {
        if (P.kind === 'railA') col = 'rgba(56,189,248,0.75)';
        else if (P.kind === 'railB') col = 'rgba(59,130,246,0.75)';
        else if (P.kind === 'spineX') col = 'rgba(168,85,247,0.75)';
        else col = 'rgba(77,163,255,0.75)';
      }

      ctx.fillStyle = col;
      ctx.beginPath();
      ctx.arc(P.x,P.y,3.2,0,Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    drawLegend(w,h);
  }

  // Node drawing:
  // Leaf tier: green tint
  // Rails: railA cyan-ish, railB blue-ish
  // SpineX: purple
  function drawSwitchNode(n){
    let w=90, h=38, r=12;

    let fill='rgba(255,255,255,0.04)';
    let stroke='rgba(255,255,255,0.10)';
    let labelCol='rgba(232,238,247,0.82)';

    if (n.type === 'leaf'){
      fill = 'rgba(110,231,183,0.08)';
      stroke = 'rgba(110,231,183,0.22)';
      labelCol = 'rgba(232,238,247,0.85)';
    } else if (n.type === 'rail'){
      w=106; h=40;
      if (n.id === 'RA'){
        fill = 'rgba(56,189,248,0.10)';
        stroke = 'rgba(56,189,248,0.26)';
      } else {
        fill = 'rgba(59,130,246,0.10)';
        stroke = 'rgba(59,130,246,0.26)';
      }
      labelCol = 'rgba(232,238,247,0.90)';
    } else if (n.type === 'spineX'){
      w=106; h=40;
      fill = 'rgba(168,85,247,0.10)';
      stroke = 'rgba(168,85,247,0.26)';
      labelCol = 'rgba(232,238,247,0.90)';
    } else if (n.type === 'spine'){
      w=106; h=40;
      fill = 'rgba(77,163,255,0.08)';
      stroke = 'rgba(77,163,255,0.22)';
      labelCol = 'rgba(232,238,247,0.85)';
    }

    ctx.save();
    roundedRect(n.x - w/2, n.y - h/2, w, h, r);
    ctx.fillStyle = fill; ctx.fill();
    ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke();
    ctx.restore();

    text(n.label, n.x, n.y+5, 12, labelCol, 'center');
  }

  // Server label at bottom, GPU ports at top
  function drawServer(S){
    const top = (S.y - S.h/2);
    const bottom = top + S.h;

    ctx.save();
    roundedRect(S.x, top, S.w, S.h, 14);
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.restore();

    // subtle divider
    ctx.save();
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(S.x + 10, top + 34);
    ctx.lineTo(S.x + S.w - 10, top + 34);
    ctx.stroke();
    ctx.restore();

    // server label bottom-centered
    text(S.label, S.x + (S.w/2), bottom - 10, 12, 'rgba(232,238,247,0.78)', 'center');

    const gpuIds = S.gpuIds;
    const portY = top + 18;
    const labelY = top + 54;

    for(let i=0;i<gpuIds.length;i++){
      const gid = gpuIds[i];
      const G = nodeById(gid);
      if (!G) continue;

      // port circle
      ctx.save();
      ctx.fillStyle = 'rgba(77,163,255,0.22)';
      ctx.strokeStyle = 'rgba(77,163,255,0.38)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(G.x, portY, 7.5, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();

      // port stem
      ctx.save();
      ctx.strokeStyle = 'rgba(77,163,255,0.30)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(G.x, portY + 8.5);
      ctx.lineTo(G.x, portY + 16.5);
      ctx.stroke();
      ctx.restore();

      // GPU label
      text(G.label, G.x, labelY, 11, 'rgba(167,179,197,0.82)', 'center');

      // rail tag
      const railTag = (G.railIndex === 0) ? 'A' : 'B';
      const railCol = (G.railIndex === 0) ? 'rgba(56,189,248,0.85)' : 'rgba(59,130,246,0.85)';
      text(`R${railTag}`, G.x, portY - 10, 10, railCol, 'center');
    }
  }

  function drawLegend(w,h){
    const baseX = 28;
    const baseY = h - 34;

    text('Link heat (overrides tint when hot):', baseX, baseY, 12, 'rgba(167,179,197,0.9)');

    const swY = baseY - 12;
    const swW = 58;
    const swH = 14;
    const gap = 18;

    const x1 = baseX + 230;
    const x2 = x1 + swW + gap + 42;
    const x3 = x2 + swW + gap + 42;

    swatch(x1, swY, swW, swH, 'rgba(77,163,255,0.65)', 'warm');
    swatch(x2, swY, swW, swH, 'rgba(255,176,32,0.65)', 'hot');
    swatch(x3, swY, swW, swH, 'rgba(255,92,92,0.65)', 'critical');

    // Rail tint mini-legend
    const y2 = swY - 28;
    text('Rail tint:', baseX, y2+12, 12, 'rgba(167,179,197,0.9)');
    tintSwatch(baseX+84, y2, 46, 14, 'rgba(56,189,248,0.65)', 'Rail A');
    tintSwatch(baseX+150, y2, 46, 14, 'rgba(59,130,246,0.65)', 'Rail B');
    tintSwatch(baseX+216, y2, 46, 14, 'rgba(168,85,247,0.65)', 'Spine');
  }

  function swatch(x,y,w,h,col,label){
    ctx.save();
    ctx.fillStyle = col;
    roundedRect(x, y, w, h, 7);
    ctx.fill();
    ctx.restore();
    text(label, x + w/2, y + h + 14, 11, 'rgba(167,179,197,0.82)', 'center');
  }
  function tintSwatch(x,y,w,h,col,label){
    ctx.save();
    ctx.fillStyle = col;
    roundedRect(x, y, w, h, 7);
    ctx.fill();
    ctx.restore();
    text(label, x + w/2, y + h + 14, 10, 'rgba(167,179,197,0.78)', 'center');
  }

  // Presets + Demo
  function applyPreset(p){
    clearDemo();
    if (p.topo) setTopo(p.topo);
    if (p.pattern) setPattern(p.pattern);

    if (p.n != null) el.n.value = p.n;
    if (p.intensity != null) el.intensity.value = p.intensity;
    if (p.hotspot != null) el.hotspot.value = p.hotspot;

    el.n.dispatchEvent(new Event('input'));
    el.intensity.dispatchEvent(new Event('input'));
    el.hotspot.dispatchEvent(new Event('input'));

    resetFlows();
    running = true;
    el.toggleRun.textContent = 'Pause';
  }

  el.pCalm.onclick = ()=> applyPreset({ topo:'rails', pattern:'alltoall', n:12, intensity:0.75, hotspot:0.45 });
  el.pHot.onclick  = ()=> applyPreset({ topo:'rails', pattern:'fanin', n:16, intensity:1.35, hotspot:0.80 });
  el.pCompare.onclick = ()=> applyPreset({ topo:'rails', pattern:'alltoall', n:16, intensity:1.05, hotspot:0.65 });

  function runDemo(){
    if (demoRunning){ clearDemo(); return; }
    demoRunning = true;
    el.demo.textContent = 'Stop Demo';

    applyPreset({ topo:'rails', pattern:'alltoall', n:16, intensity:1.05, hotspot:0.65 });

    demoTimers.push(setTimeout(()=> {
      applyPreset({ topo:'rails', pattern:'fanin', n:16, intensity:1.25, hotspot:0.80 });
    }, 9000));

    demoTimers.push(setTimeout(()=> {
      applyPreset({ topo:'leafspine', pattern:'fanin', n:16, intensity:1.25, hotspot:0.80 });
    }, 18000));

    demoTimers.push(setTimeout(()=> {
      demoRunning = false;
      el.demo.textContent = 'Demo Mode';
    }, 26000));
  }
  el.demo.onclick = runDemo;

  // Initialize
  setTopo('leafspine');
  setPattern('fanin');
  rebuild();

  el.n.addEventListener('input', ()=> rebuild());

  let lastTs = performance.now();
  function tick(ts){
    const dt = Math.min(0.05, (ts-lastTs)/1000);
    lastTs = ts;
    if (running) step(dt);
    render();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
